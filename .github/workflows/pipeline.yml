name: CI/CD Pipeline

permissions:
  contents: write
  issues: write
  pull-requests: write

on:
  pull_request:
    branches: [main, develop]
  push:
    branches: [main, develop]
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy (e.g., v1.0.0)'
        required: true
        type: string

env:
  DOCKER_REGISTRY: ${{ secrets.DOCKER_HUB_USERNAME }}

jobs:
  # ============================================================================
  # CI STAGE - Code Quality & Tests
  # ============================================================================

  backend-lint:
    name: Backend - Lint & Type Check
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        working-directory: ./backend
        run: npm ci

      - name: Run ESLint
        working-directory: ./backend
        run: npm run lint || true

      - name: TypeScript type check
        working-directory: ./backend
        run: npx tsc --noEmit

  backend-test:
    name: Backend - Tests
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:14-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          cache-dependency-path: backend/package-lock.json

      - name: Install dependencies
        working-directory: ./backend
        run: npm ci

      - name: Run tests
        working-directory: ./backend
        env:
          POSTGRES_HOST: localhost
          POSTGRES_PORT: 5432
          POSTGRES_DB: test_db
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
        run: npm test || echo "No tests configured yet"

  frontend-lint:
    name: Frontend - Lint & Type Check
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Run ESLint
        working-directory: ./frontend
        run: npm run lint || true

      - name: TypeScript type check
        working-directory: ./frontend
        run: npx tsc --noEmit

  frontend-test:
    name: Frontend - Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Run tests
        working-directory: ./frontend
        run: npm test -- --watchAll=false || echo "No tests configured yet"

  frontend-build:
    name: Frontend - Build Check
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Build frontend
        working-directory: ./frontend
        env:
          REACT_APP_API_URL: https://api.example.com/
        run: npm run build

      - name: Check build size
        working-directory: ./frontend
        run: |
          BUILD_SIZE=$(du -sh build | cut -f1)
          echo "Build size: $BUILD_SIZE"

  docker-build-test:
    name: Docker - Build Test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build backend Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile.pub
          push: false
          tags: backend-test:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build frontend Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile.pub
          push: false
          tags: frontend-test:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            REACT_APP_API_URL=https://api.example.com/

  ci-status:
    name: CI Status Check
    runs-on: ubuntu-latest
    needs: [backend-lint, backend-test, frontend-lint, frontend-test, frontend-build, docker-build-test]
    if: always()

    steps:
      - name: Check CI results
        run: |
          if [[ "${{ needs.backend-lint.result }}" == "failure" ]] || \
             [[ "${{ needs.backend-test.result }}" == "failure" ]] || \
             [[ "${{ needs.frontend-lint.result }}" == "failure" ]] || \
             [[ "${{ needs.frontend-test.result }}" == "failure" ]] || \
             [[ "${{ needs.frontend-build.result }}" == "failure" ]] || \
             [[ "${{ needs.docker-build-test.result }}" == "failure" ]]; then
            echo "‚ùå CI checks failed"
            exit 1
          fi
          echo "‚úÖ All CI checks passed"

  # ============================================================================
  # BUILD STAGE - Docker Images
  # ============================================================================

  build-and-push:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest
    needs: ci-status
    if: |
      success() && (
        (github.event_name == 'pull_request' && github.base_ref == 'main') ||
        github.event_name == 'release' ||
        github.event_name == 'workflow_dispatch'
      )
    outputs:
      image-tag: ${{ steps.set-vars.outputs.image-tag }}
      environment: ${{ steps.set-vars.outputs.environment }}
      api-url: ${{ steps.set-vars.outputs.api-url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set deployment variables
        id: set-vars
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "image-tag=pr-${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "api-url=${{ secrets.STAGING_API_URL }}" >> $GITHUB_OUTPUT
            echo "additional-tag=${{ env.DOCKER_REGISTRY }}/backend-compose-optimized:staging-latest" >> $GITHUB_OUTPUT
            echo "additional-tag-frontend=${{ env.DOCKER_REGISTRY }}/frontend-compose-optimized:staging-latest" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "release" ]]; then
            VERSION="${{ github.event.release.tag_name }}"
            echo "image-tag=$VERSION" >> $GITHUB_OUTPUT
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "api-url=${{ secrets.PRODUCTION_API_URL }}" >> $GITHUB_OUTPUT
            echo "additional-tag=${{ env.DOCKER_REGISTRY }}/backend-compose-optimized:latest" >> $GITHUB_OUTPUT
            echo "additional-tag-frontend=${{ env.DOCKER_REGISTRY }}/frontend-compose-optimized:latest" >> $GITHUB_OUTPUT
          else
            VERSION="${{ github.event.inputs.version }}"
            echo "image-tag=$VERSION" >> $GITHUB_OUTPUT
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "api-url=${{ secrets.PRODUCTION_API_URL }}" >> $GITHUB_OUTPUT
            echo "additional-tag=${{ env.DOCKER_REGISTRY }}/backend-compose-optimized:latest" >> $GITHUB_OUTPUT
            echo "additional-tag-frontend=${{ env.DOCKER_REGISTRY }}/frontend-compose-optimized:latest" >> $GITHUB_OUTPUT
          fi

      - name: Validate version (production only)
        if: steps.set-vars.outputs.environment == 'production'
        run: |
          VERSION="${{ steps.set-vars.outputs.image-tag }}"
          if [[ ! $VERSION =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "‚ùå Invalid version format: $VERSION (expected: v1.0.0)"
            exit 1
          fi
          echo "‚úÖ Version format valid: $VERSION"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile.pub
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/backend-compose-optimized:${{ steps.set-vars.outputs.image-tag }}
            ${{ steps.set-vars.outputs.additional-tag }}
          cache-from: type=registry,ref=${{ env.DOCKER_REGISTRY }}/backend-compose-optimized:buildcache
          cache-to: type=registry,ref=${{ env.DOCKER_REGISTRY }}/backend-compose-optimized:buildcache,mode=max
          platforms: linux/amd64

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile.pub
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/frontend-compose-optimized:${{ steps.set-vars.outputs.image-tag }}
            ${{ steps.set-vars.outputs.additional-tag-frontend }}
          cache-from: type=registry,ref=${{ env.DOCKER_REGISTRY }}/frontend-compose-optimized:buildcache
          cache-to: type=registry,ref=${{ env.DOCKER_REGISTRY }}/frontend-compose-optimized:buildcache,mode=max
          platforms: linux/amd64
          build-args: |
            REACT_APP_API_URL=${{ steps.set-vars.outputs.api-url }}

  # ============================================================================
  # DEPLOY STAGE - Staging
  # ============================================================================

  deploy-staging:
    name: Deploy to Staging Server
    runs-on: ubuntu-latest
    needs: build-and-push
    if: needs.build-and-push.outputs.environment == 'staging'
    environment:
      name: staging
      url: https://stage.nomoredomainswork.ru

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create .env.staging file
        run: |
          cat > .env.staging << EOF
          # PostgreSQL Configuration
          POSTGRES_HOST=postgres-staging
          POSTGRES_PORT=5432
          POSTGRES_DB=${{ secrets.STAGING_POSTGRES_DB }}
          POSTGRES_USER=${{ secrets.STAGING_POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.STAGING_POSTGRES_PASSWORD }}
          PGDATA=/var/lib/postgresql/data

          # Ports Configuration
          BACKEND_PORT=${{ secrets.STAGING_BACKEND_PORT }}
          FRONTEND_PORT=${{ secrets.STAGING_FRONTEND_PORT }}
          ADMINER_PORT=${{ secrets.STAGING_ADMINER_PORT }}

          # Docker Configuration
          DOCKER_REGISTRY=${{ env.DOCKER_REGISTRY }}
          IMAGE_TAG=${{ needs.build-and-push.outputs.image-tag }}

          # Application Configuration
          NODE_ENV=staging
          TYPEORM_SYNC=1
          EOF

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.STAGING_SSH_KEY }}" > ~/.ssh/staging_key
          chmod 600 ~/.ssh/staging_key
          ssh-keyscan -H ${{ secrets.STAGING_SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Copy files to staging server
        run: |
          scp -i ~/.ssh/staging_key \
            -o StrictHostKeyChecking=no \
            docker-compose.staging.yml \
            .env.staging \
            scripts/deploy-staging.sh \
            ${{ secrets.STAGING_SSH_USER }}@${{ secrets.STAGING_SSH_HOST }}:/home/deploy/staging/

      - name: Deploy on staging server
        run: |
          ssh -i ~/.ssh/staging_key \
            -o StrictHostKeyChecking=no \
            ${{ secrets.STAGING_SSH_USER }}@${{ secrets.STAGING_SSH_HOST }} \
            "cd /home/deploy/staging && \
             chmod +x deploy-staging.sh && \
             export DOCKER_HUB_USERNAME=${{ secrets.DOCKER_HUB_USERNAME }} && \
             export DOCKER_HUB_TOKEN=${{ secrets.DOCKER_HUB_TOKEN }} && \
             export BACKEND_PORT=${{ secrets.STAGING_BACKEND_PORT }} && \
             export FRONTEND_PORT=${{ secrets.STAGING_FRONTEND_PORT }} && \
             export ADMINER_PORT=${{ secrets.STAGING_ADMINER_PORT }} && \
             export POSTGRES_USER=${{ secrets.STAGING_POSTGRES_USER }} && \
             ./deploy-staging.sh"

      - name: Cleanup SSH key
        if: always()
        run: rm -f ~/.ssh/staging_key

  notify-staging:
    name: Send Staging Notification
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-staging]
    if: always() && needs.build-and-push.outputs.environment == 'staging'

    steps:
      - name: Send success notification
        if: needs.deploy-staging.result == 'success'
        uses: appleboy/telegram-action@master
        with:
          to: ${{ secrets.TELEGRAM_CHAT_ID }}
          token: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          format: markdown
          message: |
            ‚úÖ *Staging Deployment Successful*

            *PR:* #${{ github.event.pull_request.number }} - ${{ github.event.pull_request.title }}
            *Author:* ${{ github.event.pull_request.user.login }}
            *Branch:* `${{ github.head_ref }}`
            *Commit:* `${{ github.sha }}`

            *Environment:* Staging
            *Image Tag:* `${{ needs.build-and-push.outputs.image-tag }}`

            *URLs:*
            üåê Frontend: https://stage.nomoredomainswork.ru
            üîß Backend: https://api.stage.nomoredomainswork.ru

            [View PR](${{ github.event.pull_request.html_url }})

      - name: Send failure notification
        if: needs.deploy-staging.result == 'failure'
        uses: appleboy/telegram-action@master
        with:
          to: ${{ secrets.TELEGRAM_CHAT_ID }}
          token: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          format: markdown
          message: |
            ‚ùå *Staging Deployment Failed*

            *PR:* #${{ github.event.pull_request.number }} - ${{ github.event.pull_request.title }}
            *Author:* ${{ github.event.pull_request.user.login }}
            *Branch:* `${{ github.head_ref }}`
            *Commit:* `${{ github.sha }}`

            *Environment:* Staging

            [View Workflow Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            [View PR](${{ github.event.pull_request.html_url }})

  comment-on-pr:
    name: Comment on Pull Request
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-staging]
    if: needs.deploy-staging.result == 'success'

    steps:
      - name: Comment PR
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prNumber = context.payload.pull_request.number;
            const imageTag = '${{ needs.build-and-push.outputs.image-tag }}';

            const comment = `## üöÄ Staging Deployment Successful

            Your changes have been deployed to the staging environment!

            ### üîó URLs
            - **Frontend:** https://stage.nomoredomainswork.ru
            - **Backend API:** https://api.stage.nomoredomainswork.ru
            - **Adminer:** http://85.143.172.140:9001

            ### üê≥ Docker Images
            - Backend: \`${{ env.DOCKER_REGISTRY }}/backend-compose-optimized:${imageTag}\`
            - Frontend: \`${{ env.DOCKER_REGISTRY }}/frontend-compose-optimized:${imageTag}\`

            ### üìù Testing Instructions
            1. Test your changes on the staging environment
            2. Verify all functionality works as expected
            3. Once approved, this PR can be merged to trigger production deployment

            ---
            *Deployed from commit: ${context.sha.substring(0, 7)}*`;

            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: comment
            });

  # ============================================================================
  # DEPLOY STAGE - Production
  # ============================================================================

  deploy-production:
    name: Deploy to Production Server
    runs-on: ubuntu-latest
    needs: build-and-push
    if: needs.build-and-push.outputs.environment == 'production'
    environment:
      name: production
      url: https://prod.nomorepartiessbs.ru

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get release info
        id: release-info
        if: github.event_name == 'release'
        run: |
          echo "release_name=${{ github.event.release.name }}" >> $GITHUB_OUTPUT
          echo "release_url=${{ github.event.release.html_url }}" >> $GITHUB_OUTPUT
          echo "author=${{ github.event.release.author.login }}" >> $GITHUB_OUTPUT

      - name: Create .env.production file
        run: |
          cat > .env.production << EOF
          # PostgreSQL Configuration
          POSTGRES_HOST=postgres-production
          POSTGRES_PORT=5432
          POSTGRES_DB=${{ secrets.PRODUCTION_POSTGRES_DB }}
          POSTGRES_USER=${{ secrets.PRODUCTION_POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.PRODUCTION_POSTGRES_PASSWORD }}
          PGDATA=/var/lib/postgresql/data

          # Ports Configuration
          BACKEND_PORT=${{ secrets.PRODUCTION_BACKEND_PORT }}
          FRONTEND_PORT=${{ secrets.PRODUCTION_FRONTEND_PORT }}
          ADMINER_PORT=${{ secrets.PRODUCTION_ADMINER_PORT }}

          # Docker Configuration
          DOCKER_REGISTRY=${{ env.DOCKER_REGISTRY }}
          IMAGE_TAG=${{ needs.build-and-push.outputs.image-tag }}

          # Application Configuration
          NODE_ENV=production
          TYPEORM_SYNC=0
          EOF

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/production_key
          chmod 600 ~/.ssh/production_key
          ssh-keyscan -H ${{ secrets.PRODUCTION_SSH_HOST }} >> ~/.ssh/known_hosts

      - name: Copy files to production server
        run: |
          scp -i ~/.ssh/production_key \
            -o StrictHostKeyChecking=no \
            docker-compose.production.yml \
            .env.production \
            scripts/deploy-production.sh \
            ${{ secrets.PRODUCTION_SSH_USER }}@${{ secrets.PRODUCTION_SSH_HOST }}:/home/deploy/production/

      - name: Deploy on production server
        run: |
          ssh -i ~/.ssh/production_key \
            -o StrictHostKeyChecking=no \
            ${{ secrets.PRODUCTION_SSH_USER }}@${{ secrets.PRODUCTION_SSH_HOST }} \
            "cd /home/deploy/production && \
             chmod +x deploy-production.sh && \
             export DOCKER_HUB_USERNAME=${{ secrets.DOCKER_HUB_USERNAME }} && \
             export DOCKER_HUB_TOKEN=${{ secrets.DOCKER_HUB_TOKEN }} && \
             export BACKEND_PORT=${{ secrets.PRODUCTION_BACKEND_PORT }} && \
             export FRONTEND_PORT=${{ secrets.PRODUCTION_FRONTEND_PORT }} && \
             export ADMINER_PORT=${{ secrets.PRODUCTION_ADMINER_PORT }} && \
             export POSTGRES_USER=${{ secrets.PRODUCTION_POSTGRES_USER }} && \
             ./deploy-production.sh"

      - name: Verify deployment
        run: |
          echo "‚úÖ Production deployment completed"
          echo "Backend: https://api.prod.nomorepartiessbs.ru"
          echo "Frontend: https://prod.nomorepartiessbs.ru"

      - name: Cleanup SSH key
        if: always()
        run: rm -f ~/.ssh/production_key

  notify-production:
    name: Send Production Notification
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-production]
    if: always() && needs.build-and-push.outputs.environment == 'production'

    steps:
      - name: Get release info
        id: release-info
        if: github.event_name == 'release'
        run: |
          echo "release_name=${{ github.event.release.name }}" >> $GITHUB_OUTPUT
          echo "release_url=${{ github.event.release.html_url }}" >> $GITHUB_OUTPUT
          echo "author=${{ github.event.release.author.login }}" >> $GITHUB_OUTPUT

      - name: Send success notification
        if: needs.deploy-production.result == 'success'
        uses: appleboy/telegram-action@master
        with:
          to: ${{ secrets.TELEGRAM_CHAT_ID }}
          token: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          format: markdown
          message: |
            üöÄ *Production Deployment Successful*

            *Version:* `${{ needs.build-and-push.outputs.image-tag }}`
            *Release:* ${{ steps.release-info.outputs.release_name }}
            *Deployed by:* ${{ steps.release-info.outputs.author }}
            *Commit:* `${{ github.sha }}`

            *Environment:* Production üî¥

            *URLs:*
            üåê Frontend: https://prod.nomorepartiessbs.ru
            üîß Backend: https://api.prod.nomorepartiessbs.ru

            *Docker Images:*
            ‚Ä¢ Backend: `${{ env.DOCKER_REGISTRY }}/backend-compose-optimized:${{ needs.build-and-push.outputs.image-tag }}`
            ‚Ä¢ Frontend: `${{ env.DOCKER_REGISTRY }}/frontend-compose-optimized:${{ needs.build-and-push.outputs.image-tag }}`

            [View Release](${{ steps.release-info.outputs.release_url }})

      - name: Send failure notification
        if: needs.deploy-production.result == 'failure'
        uses: appleboy/telegram-action@master
        with:
          to: ${{ secrets.TELEGRAM_CHAT_ID }}
          token: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          format: markdown
          message: |
            ‚ùå *Production Deployment Failed*

            *Version:* `${{ needs.build-and-push.outputs.image-tag }}`
            *Commit:* `${{ github.sha }}`

            *Environment:* Production üî¥

            [View Workflow Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

  create-deployment-tag:
    name: Create Deployment Tag
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-production]
    if: needs.deploy-production.result == 'success' && github.event_name == 'release'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create deployment tag
        run: |
          DEPLOY_TAG="deployed-${{ needs.build-and-push.outputs.image-tag }}-$(date +%Y%m%d-%H%M%S)"
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$DEPLOY_TAG" -m "Production deployment of ${{ needs.build-and-push.outputs.image-tag }}"
          git push origin "$DEPLOY_TAG"
          echo "‚úÖ Created deployment tag: $DEPLOY_TAG"

  update-release-notes:
    name: Update Release Notes
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-production]
    if: |
      needs.deploy-production.result == 'success' &&
      github.event_name == 'release'

    steps:
      - name: Update release with deployment info
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const releaseId = context.payload.release.id;
            const release = await github.rest.repos.getRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId
            });

            const currentBody = release.data.body || '';
            const deploymentInfo = `

            ---

            ## üöÄ Deployment Information

            **Deployed to Production:** ${new Date().toISOString()}
            **Deployed by:** @${context.actor}
            **Workflow Run:** [View Logs](${context.payload.repository.html_url}/actions/runs/${context.runId})

            **Docker Images:**
            - Backend: \`${{ env.DOCKER_REGISTRY }}/backend-compose-optimized:${{ needs.build-and-push.outputs.image-tag }}\`
            - Frontend: \`${{ env.DOCKER_REGISTRY }}/frontend-compose-optimized:${{ needs.build-and-push.outputs.image-tag }}\`

            **Production URLs:**
            - Frontend: https://prod.nomorepartiessbs.ru
            - Backend API: https://api.prod.nomorepartiessbs.ru
            `;

            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId,
              body: currentBody + deploymentInfo
            });
